{
  ".env-example": "NGROK_AUTHTOKEN=\r\n\r\nTWITCH_CLIENT_ID=\r\nTWITCH_CLIENT_SECRET=\r\nTWITCH_USERNAME=\r\nTWITCH_REDIRECT_URL=https://****************.ngrok-free.app/twitch/redirect/clip\r\n\r\nTWITTER_API_KEY=\r\nTWITTER_API_SECRET=\r\nTWITTER_ACCESS_TOKEN=\r\nTWITTER_ACCESS_TOKEN_SECRET=",
  ".gitignore": ".idea\r\n.env\r\n.secrets\r\nnode_modules\r\npackage-lock.json\r\n.combined.json",
  "package.json": "{\n  \"name\": \"server\",\n  \"version\": \"1.0.0\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"combine\": \"node src/helpers/util/combine.js\",\n    \"uncombine\": \"node src/helpers/util/uncombine.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"devDependencies\": {\n    \"@ngrok/ngrok\": \"^1.4.1\",\n    \"axios\": \"^1.7.7\",\n    \"chalk\": \"^2.4.2\",\n    \"dotenv-cli\": \"^7.4.2\",\n    \"express\": \"^4.21.1\",\n    \"glob\": \"^11.0.0\",\n    \"twitter-api-v2\": \"^1.18.2\"\n  }\n}\n",
  "src\\index.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst express = require('express');\r\nconst {startNgrok} = require('./helpers/ngrok/launcher'); // Import Ngrok helper\r\nconst {tweet} = require('./helpers/twitter/sender'); // Import Twitter helper\r\nconst {setParam} = require('./helpers/store/manager'); // Import the callbackHelper function\r\nconst {getSecret} = require('./helpers/store/manager'); // Import the getSecret method\r\nconst {twitchLogin} = require('./helpers/twitch/oauth'); // Import the twitchLogin function\r\nconst {clipHelper} = require('./helpers/twitch/clip'); // Import the clipHelper function\r\n\r\nconst app = express();\r\nconst PORT = 80; // Local port for your server\r\n\r\napp.get('/tweet', (req, res) => tweet(req, res));\r\n\r\napp.get('/twitch/login', (req, res) => {\r\n    const twitch_login_intent = req.query.twitch_login_intent || null;\r\n    console.log(`Redirecting to Twitch login with intent: ${twitch_login_intent}`);\r\n\r\n    if (twitch_login_intent) {\r\n        setParam('twitch_login_intent', twitch_login_intent);\r\n    }\r\n\r\n    twitchLogin(req, res);\r\n});\r\n\r\napp.get('/twitch/clip', (req, res) => {\r\n    // Check if the 'access_token' and 'refresh_token' exist in the secret file\r\n    const accessToken = getSecret('access_token');\r\n    const refreshToken = getSecret('refresh_token');\r\n\r\n    if (accessToken && refreshToken) {\r\n        // Tokens are present, proceed to redirect to the clip creation endpoint\r\n        console.log('Access token and refresh token found, redirecting to /twitch/redirect/clip');\r\n        return res.redirect('/twitch/redirect/clip');\r\n    }\r\n\r\n    // If tokens are not present, initiate the login flow\r\n    console.log('Access token or refresh token not found, redirecting to /twitch/login');\r\n    res.redirect('/twitch/login?twitch_login_intent=/twitch/redirect/clip');\r\n});\r\n\r\napp.get('/twitch/redirect/clip', (req, res) => clipHelper(req, res));\r\n\r\nasync function startServices() {\r\n    try {\r\n        const publicUrl = await startNgrok(PORT);\r\n\r\n        app.listen(PORT, () => {\r\n            console.log(`App service running locally on http://localhost:${PORT}`);\r\n            console.log(`TWEET: ${publicUrl}/tweet?m=HelloWorld`);\r\n            console.log(`Twitch LOGIN: ${publicUrl}/twitch/login?twitch_login_intent=/twitch/redirect/clip`);\r\n            console.log(`CLIP: ${publicUrl}/twitch/clip`);\r\n        });\r\n    } catch (err) {\r\n        console.error('Error initializing services:', err);\r\n    }\r\n}\r\n\r\nstartServices();\r\n",
  "src\\helpers\\util\\uncombine.js": "const fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Path to the combined JSON file\r\nconst combinedJsonPath = path.join(process.cwd(), '.combined.json');\r\n\r\n// Function to write content back to the files\r\nfunction uncombine() {\r\n    try {\r\n        // Read the combined JSON file\r\n        const combinedData = JSON.parse(fs.readFileSync(combinedJsonPath, 'utf-8'));\r\n\r\n        // Iterate through each file in the combined data\r\n        for (const filePath in combinedData) {\r\n            const content = combinedData[filePath];\r\n            const absoluteFilePath = path.join(process.cwd(), filePath);\r\n\r\n            // Check if the file exists\r\n            if (fs.existsSync(absoluteFilePath)) {\r\n                console.log(`Warning: File already exists at ${absoluteFilePath}. It will be overwritten.`);\r\n            }\r\n\r\n            // Create directories if they don't exist\r\n            const dirPath = path.dirname(absoluteFilePath);\r\n            if (!fs.existsSync(dirPath)) {\r\n                fs.mkdirSync(dirPath, { recursive: true });\r\n                console.log(`Created directory: ${dirPath}`);\r\n            }\r\n\r\n            // Write the content to the respective file\r\n            fs.writeFileSync(absoluteFilePath, content, 'utf-8');\r\n            console.log(`File written: ${absoluteFilePath}`);\r\n        }\r\n\r\n        console.log('Uncombining completed successfully.');\r\n    } catch (error) {\r\n        console.error('Error during uncombine process:', error);\r\n    }\r\n}\r\n\r\n// Run the uncombine function\r\nuncombine();\r\n",
  "src\\helpers\\util\\combine.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst glob = require('glob');\r\n\r\n// Specify the glob pattern for your JS files (including subdirectories)\r\nconst jsFilePatterns = [\r\n    \"src/**/*.js\", // This will match all JS files in 'src' and subdirectories\r\n    \".env-example\",\r\n    \".gitignore\",\r\n    \"package.json\",\r\n];\r\n\r\n// Initialize an object to hold the combined content\r\nconst combined = {};\r\n\r\n// Use globSync to find all the JS files matching the patterns\r\nconst files = glob.sync(jsFilePatterns);\r\n\r\nfiles.forEach(file => {\r\n    // Get the relative path based on the current working directory\r\n    const relativePath = path.relative(process.cwd(), file);\r\n\r\n    // Log the absolute and relative paths of each file\r\n    console.log(`Processing file: ${relativePath}`); // Log the relative path\r\n\r\n    const fileContent = fs.readFileSync(file, 'utf-8');\r\n    combined[relativePath] = fileContent;\r\n});\r\n\r\n// Write the combined object to .combined.json\r\nfs.writeFileSync(path.join(process.cwd(), '.combined.json'), JSON.stringify(combined, null, 2));\r\n\r\nconsole.log('All JS files have been combined into .combined.json');\r\n",
  "src\\helpers\\twitter\\sender.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst { TwitterApi } = require('twitter-api-v2');\r\n\r\n// Editable hashtags - you can modify these\r\nconst HASHTAGS = '#twitch #twitchstreamer #gaming #gamer #streamer #youtube #twitchaffiliate #twitchtv #livefromtwitch #live';\r\n\r\n// Initialize Twitter client with credentials from environment variables\r\nconst twitterClient = new TwitterApi({\r\n    appKey: process.env.TWITTER_API_KEY,\r\n    appSecret: process.env.TWITTER_API_SECRET,\r\n    accessToken: process.env.TWITTER_ACCESS_TOKEN,\r\n    accessSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET,\r\n});\r\n\r\n// Function to handle tweeting\r\nasync function sender(req, res) {\r\n    try {\r\n        const message = req.query.m; // Get the tweet message from the query parameter\r\n        if (!message) {\r\n            return res.send('No message provided for tweeting.');\r\n        }\r\n\r\n        // Append hashtags to the message\r\n        const tweetMessage = `${message} ${HASHTAGS}`;\r\n\r\n        // Post the tweet and await the response\r\n        const tweetResponse = await twitterClient.v2.tweet(tweetMessage);\r\n\r\n        // Send the response back as a confirmation message\r\n        res.send(`Tweet posted successfully: ${tweetResponse.data.text}`);\r\n    } catch (error) {\r\n        console.error('Error posting tweet:', error);\r\n        res.send('Failed to post tweet: ' + error.message);\r\n    }\r\n}\r\n\r\nmodule.exports = { tweet: sender };\r\n",
  "src\\helpers\\twitch\\oauth.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst { getSecret,setSecret} = require('../store/manager'); // Import setParam to save parameters\r\nconst axios = require('axios');\r\n\r\n// Function to generate the OAuth login URL and redirect the user\r\nfunction twitchLogin(req, res) {\r\n    const TWITCH_CLIENT_ID = process.env.TWITCH_CLIENT_ID;\r\n    const TWITCH_REDIRECT_URL = process.env.TWITCH_REDIRECT_URL;\r\n    const TWITCH_SCOPES = 'clips:edit';\r\n\r\n    const twitch_login_intent = req.query.twitch_login_intent || null;\r\n    console.log(`twitchLogin called with twitch_login_intent: ${twitch_login_intent}`);\r\n\r\n    // If no 'twitch_login_intent' is provided, stop the flow and do nothing\r\n    if (!twitch_login_intent) {\r\n        console.log('No twitch_login_intent provided. Stopping the flow.');\r\n        return res.status(400).send('No valid intent provided.');\r\n    }\r\n\r\n    // Otherwise, proceed with the regular OAuth flow\r\n    const oauthUrl = `https://id.twitch.tv/oauth2/authorize?client_id=${TWITCH_CLIENT_ID}&redirect_uri=${encodeURIComponent(TWITCH_REDIRECT_URL)}&response_type=code&scope=${TWITCH_SCOPES}`;\r\n    res.redirect(oauthUrl); // Redirect the user to the Twitch login URL\r\n}\r\n\r\n// Function to exchange the OAuth code for an access token and refresh token\r\nasync function getOAuthTokens(code) {\r\n    try {\r\n        const response = await axios.post('https://id.twitch.tv/oauth2/token', null, {\r\n            params: {\r\n                client_id: process.env.TWITCH_CLIENT_ID,\r\n                client_secret: process.env.TWITCH_CLIENT_SECRET,\r\n                code: code,\r\n                grant_type: 'authorization_code',\r\n                redirect_uri: process.env.TWITCH_REDIRECT_URL,\r\n            },\r\n        });\r\n\r\n        const accessToken = response.data.access_token;\r\n        const refreshToken = response.data.refresh_token;\r\n\r\n        // Store the access token and refresh token in .secrets file\r\n        setSecret('access_token', accessToken); // Save access_token\r\n        setSecret('refresh_token', refreshToken); // Save refresh_token\r\n\r\n        // Log the response and tokens\r\n        console.log('OAuth token response:', response.data);\r\n        console.log('Access Token:', accessToken);\r\n        console.log('Refresh Token:', refreshToken);\r\n\r\n        return response.data; // Return the access token and refresh token\r\n    } catch (error) {\r\n        console.error('Error exchanging code for tokens:', error.response?.data || error.message);\r\n        throw new Error('Failed to get OAuth tokens');\r\n    }\r\n}\r\n\r\n// Function to get the broadcaster's ID by username\r\nasync function getBroadcasterId(username) {\r\n    try {\r\n        const accessToken = getSecret('access_token'); // Get the access token from setParam\r\n        const response = await axios.get(`https://api.twitch.tv/helix/users?login=${username}`, {\r\n            headers: {\r\n                'Client-ID': process.env.TWITCH_CLIENT_ID,\r\n                Authorization: `Bearer ${accessToken}`, // Use the access token here\r\n            },\r\n        });\r\n\r\n        if (response.data.data && response.data.data.length > 0) {\r\n            return response.data.data[0].id; // Return the broadcaster ID\r\n        } else {\r\n            throw new Error('No broadcaster found');\r\n        }\r\n    } catch (error) {\r\n        console.error('Error fetching broadcaster ID:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\nmodule.exports = {twitchLogin, getOAuthTokens, getBroadcasterId};\r\n",
  "src\\helpers\\twitch\\clip.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst axios = require('axios');\r\nconst { getBroadcasterId } = require('./oauth'); // Import the getBroadcasterId to access stored params\r\nconst { getSecret } = require('../store/manager'); // Import getSecret to fetch the access token\r\n\r\nasync function clipHelper(req, res) {\r\n    try {\r\n\r\n        // Retrieve the access token from the .secrets file\r\n        const accessToken = getSecret('access_token');\r\n        if (!accessToken) {\r\n            return res.status(400).send('Access token is missing. Please authenticate first.');\r\n        }\r\n\r\n        // Get the broadcaster's ID using the username\r\n        const broadcasterId = await getBroadcasterId(process.env.TWITCH_USERNAME);\r\n\r\n        // Log the broadcaster ID to verify\r\n        console.log('Broadcaster ID:', broadcasterId);\r\n\r\n        // Make the API call to create the clip\r\n        const response = await axios.post(\r\n            'https://api.twitch.tv/helix/clips',\r\n            {\r\n                broadcaster_id: broadcasterId, // Use the broadcaster ID obtained\r\n            },\r\n            {\r\n                headers: {\r\n                    'Client-ID': process.env.TWITCH_CLIENT_ID,\r\n                    Authorization: `Bearer ${accessToken}`,\r\n                },\r\n            }\r\n        );\r\n\r\n        if (response.data.error === 'Not Found' && response.data.message === 'Clipping is not possible for an offline channel.') {\r\n            return res.status(404).send('Clipping is not possible for an offline channel. Please make sure the channel is online and try again.');\r\n        }\r\n\r\n        const clipId = response.data.data[0].id;\r\n        const clipUrl = `https://clips.twitch.tv/${clipId}`;\r\n\r\n        res.send(`Clip created successfully: ${clipUrl}`); // Return the clip URL\r\n    } catch (error) {\r\n        // Log detailed error for debugging\r\n        console.error('Error creating clip:', error.response?.data || error.message);\r\n\r\n        if (error.response?.data?.message === 'Clipping is not possible for an offline channel.') {\r\n            return res.status(404).send('Clipping is not possible for an offline channel. Please make sure the channel is online and try again.');\r\n        }\r\n\r\n        res.send('Failed to create clip: ' + error.message); // Return an error if something goes wrong\r\n    }\r\n}\r\n\r\nmodule.exports = { clipHelper };\r\n",
  "src\\helpers\\store\\manager.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst chalk = require('chalk'); // Require chalk for colorizing output\r\nconst fs = require('fs'); // Import fs module to interact with files\r\n\r\n// Singleton to store query parameters\r\nlet params = {}; // This object will hold all the query parameters\r\n\r\n// Function to set a parameter in the singleton object\r\nfunction setParam(key, value) {\r\n    params[key] = value; // Set the parameter in the global object\r\n    // Colorizing the \"set\" action with blue bg and bright white text\r\n    console.log(chalk.bgBlue.whiteBright(`Set ${key} = ${value}`));\r\n}\r\n\r\n// Function to get a parameter from the singleton object\r\nfunction getParam(key) {\r\n    // Colorizing the \"get\" action with blue bg and bright white text\r\n    console.log(chalk.bgBlue.whiteBright(`Get ${key} = ${params[key]}`));\r\n    return params[key]; // Return the value for the provided key\r\n}\r\n\r\n// Function to set a secret in the .secrets file\r\nfunction setSecret(name, key) {\r\n    try {\r\n        // Check if the .secrets file exists, if not create it\r\n        let secrets = {};\r\n        if (fs.existsSync('.secrets')) {\r\n            // Read the existing secrets from the .secrets file\r\n            secrets = JSON.parse(fs.readFileSync('.secrets', 'utf8'));\r\n        }\r\n\r\n        // Add or update the secret\r\n        secrets[name] = key;\r\n\r\n        // Write the updated secrets object back to the file\r\n        fs.writeFileSync('.secrets', JSON.stringify(secrets, null, 2), 'utf8');\r\n        console.log(chalk.bgGreen.whiteBright(`Secret set for ${name}: ${key}`));\r\n    } catch (error) {\r\n        console.error(chalk.bgRed.whiteBright('Error setting secret:', error.message));\r\n    }\r\n}\r\n\r\n// Function to get a secret from the .secrets file\r\nfunction getSecret(name) {\r\n    try {\r\n        if (fs.existsSync('.secrets')) {\r\n            // Read the secrets from the .secrets file\r\n            const secrets = JSON.parse(fs.readFileSync('.secrets', 'utf8'));\r\n\r\n            // Return the secret value if it exists\r\n            if (secrets[name]) {\r\n                return secrets[name];\r\n            } else {\r\n                console.log(chalk.bgYellow.whiteBright(`Secret ${name} not found.`));\r\n                return null;\r\n            }\r\n        } else {\r\n            console.log(chalk.bgYellow.whiteBright('No secrets file found.'));\r\n            return null;\r\n        }\r\n    } catch (error) {\r\n        console.error(chalk.bgRed.whiteBright('Error getting secret:', error.message));\r\n        return null;\r\n    }\r\n}\r\n\r\n// Function to handle the OAuth redirect and capture query parameters\r\nasync function manager(req, res) {\r\n    try {\r\n        const queryParams = req.query; // Capture all query parameters from the URL\r\n\r\n        // Store each query parameter in the singleton object\r\n        for (const [key, value] of Object.entries(queryParams)) {\r\n            setParam(key, value); // Automatically set each parameter\r\n        }\r\n\r\n        // Respond with success and the stored parameters\r\n        res.send({ message: 'Query parameters captured successfully', params: queryParams });\r\n    } catch (error) {\r\n        console.error('Error handling OAuth redirect:', error);\r\n        res.status(500).send('Failed to capture parameters');\r\n    }\r\n}\r\n\r\nmodule.exports = { setParam, getParam, setSecret, getSecret, callbackHelper: manager };\r\n",
  "src\\helpers\\ngrok\\launcher.js": "require('dotenv').config(); // Load environment variables from .env\r\nconst ngrok = require('@ngrok/ngrok');\r\n\r\nasync function startNgrok(port) {\r\n    try {\r\n        // Connect to Ngrok using a specified static domain\r\n        const tunnel = await ngrok.connect({\r\n            addr: port,\r\n            authtoken: process.env.NGROK_AUTHTOKEN,\r\n            domain: 'longhorn-learning-dodo.ngrok-free.app', // Specify your static Ngrok domain here\r\n        });\r\n\r\n        const publicUrl = await tunnel.url(); // Access the public URL\r\n        return publicUrl;\r\n    } catch (err) {\r\n        console.error('Error starting Ngrok:', err);\r\n        throw err;\r\n    }\r\n}\r\n\r\nmodule.exports = { startNgrok };\r\n"
}